<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GCP on KaiChu</title><link>https://kaichu.io/tags/gcp/</link><description>Recent content in GCP on KaiChu</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 20 Apr 2021 21:54:06 +0800</lastBuildDate><atom:link href="https://kaichu.io/tags/gcp/index.xml" rel="self" type="application/rss+xml"/><item><title>Github Assets Cnb</title><link>https://kaichu.io/posts/github-assets-cnb/</link><pubDate>Tue, 20 Apr 2021 21:54:06 +0800</pubDate><guid>https://kaichu.io/posts/github-assets-cnb/</guid><description>&lt;div class="fancybox">
&lt;a data-fancybox="gallery" href="https://kaichu.io/posts/github-assets-cnb/img/1.png" data-caption="">
&lt;img src="https://kaichu.io/posts/github-assets-cnb/img/1.png" />
&lt;/a>
&lt;/div>
&lt;p>在構建 container image 時，有時候會有需求動態下載 Github repo 中的 Assets 檔案，簡單的方式就是在 &lt;code>dockerfile&lt;/code> 透過 &lt;code>curl&lt;/code> 指令來獲取檔案，如果是 private repo 時另外配置 &lt;code>TOKEN&lt;/code> 即可&lt;/p></description></item><item><title>Build Your Buildpack</title><link>https://kaichu.io/posts/build-your-buildpack/</link><pubDate>Thu, 08 Apr 2021 13:58:19 +0800</pubDate><guid>https://kaichu.io/posts/build-your-buildpack/</guid><description>在 Buildpack Tips and Tricks ｜ KaiChu 上一篤文章中我們提到了 Cloud Native Buildpacks 專案發起的目的還有一些使用上的心得，一般的使用情境就是選擇適合的 builder (Google, Heroku, Paketo)，必要時可以指定額外的 buildpack 。本篇文章稍後也會介紹如何編寫自己的 buildpack 及如何發佈至</description></item><item><title>Buildpack Tips and Tricks</title><link>https://kaichu.io/posts/buildpack-tips-and-tricks/</link><pubDate>Fri, 02 Apr 2021 23:06:07 +0800</pubDate><guid>https://kaichu.io/posts/buildpack-tips-and-tricks/</guid><description>2018 年去上海參加 Kubecon 就有聽到過 CNCF 下的 Cloud Native Buildpacks 的專案。回來也有試玩了一下，概念很不錯，那時候可能整個生態系統比較不建全，試玩了一下就放到旁邊去了 不過自從 Google Cloud Next 20' - Hands-on Keynote: Building Trust for Speedy Innovation 中也有場次提到 Google 內部已經使用 Buildpack 的</description></item><item><title>Cloud Run Button Tips</title><link>https://kaichu.io/posts/cloud-run-button-tips/</link><pubDate>Mon, 22 Mar 2021 13:22:27 +0800</pubDate><guid>https://kaichu.io/posts/cloud-run-button-tips/</guid><description>&lt;h1 id="cloud-run">Cloud Run&lt;/h1>
&lt;p>最近為了節省 GCP 服務上的花費，將 GKE 的 cluster 的機器等級調低，相對應的是遷出部份服務到 Google managed 中，也因此重新將目光投射回 &lt;code>Cloud Run&lt;/code>&lt;/p>
&lt;p>Cloud Run 是算是 Goolge Cloud Platfrom 中 serverless (以 Knative 標準打造) 服務的其中一項，開發人員期本上只要掌握打包 Container Image 的技能就可以使用 Cloud Run，如果你不知道 Cloud Run 可以作什麼，下面官方的影片可以看一下&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/gx8VTa1c8DA" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></description></item><item><title>Establishing a Websocket PUBSUB server with NATS and Google App Engine</title><link>https://kaichu.io/posts/gae-custom-ws/</link><pubDate>Mon, 16 Mar 2020 02:00:55 +0000</pubDate><guid>https://kaichu.io/posts/gae-custom-ws/</guid><description>在設計 API server 的時候會有遇到即時訊息傳遞的需求，同步可以用 GRPC 建立連線來溝通，為了降低系統的耦合性，可以選擇非同步的方式。而 PubSub 結合 websocket 是常用的方式。對於一位 Gopher 來說，NATS 是 CNCF 下面中關於訊息傳遞的開源專案且對</description></item><item><title>CloudFunctions Google maps service</title><link>https://kaichu.io/posts/cloudfunctions-google-maps-services/</link><pubDate>Fri, 18 Aug 2017 00:42:29 +0000</pubDate><guid>https://kaichu.io/posts/cloudfunctions-google-maps-services/</guid><description>&lt;h3 id="waldo-gcp">Waldo-gcp&lt;/h3>
&lt;p>&lt;a href="https://www.slideshare.net/cagechung/waldogcp">Waldo-gcp&lt;/a> 在 2015 時 Google I/O Extended Taipei 時分享過一個計算最佳路徑的微服務。在提供幾組 Google Maps 上有效的地址，透過 Google Maps Distance Matrix API 來計算出每一個點一點之間的旅行距離及旅行時間。再透過基因演算出計算出周遊一圈旅行最短路徑&lt;/p>
&lt;pre>&lt;code class="language-shell"># 提供5組 Google Maps 上有效的地址
台北市內湖區瑞光路227號1樓,
高雄市鼓山區美術東二路106號,
台南市長榮路一段175號,
臺北市松山區南京東路五段123巷1弄15號,
高雄市五福四路131號2樓
&lt;/code>&lt;/pre></description></item><item><title>Google Announce Application Default Credentials (ADC)</title><link>https://kaichu.io/posts/adc/</link><pubDate>Tue, 21 Jul 2015 10:04:40 +0800</pubDate><guid>https://kaichu.io/posts/adc/</guid><description>&lt;p>今天 Google 公佈了 &lt;a href="http://googlecloudplatform.blogspot.tw/2015/07/Easier-Auth-for-Google-Cloud-APIs-Introducing-the-Application-Default-Credentials-feature.html">Application Default Credentials (ADC)&lt;/a>，一個可以讓使用者更方便在 GCP 上去界接其他的需要使用 OAuth 存取的服務如 &lt;a href="https://cloud-dot-devsite.googleplex.com/storage">Google Cloud Storage&lt;/a>、&lt;a href="https://cloud-dot-devsite.googleplex.com/bigquery">Google BigQuery&lt;/a>。這對常常寫 GAE 的我來說又更方便了。&lt;/p>
&lt;p>在 GCP 專案建立之後，預設會自動產生 &lt;a href="https://developers.google.com/accounts/docs/OAuth2ServiceAccount">Service Accounts&lt;/a>，
這些內建的 Service Accounts 在進行 Server to Server 的存取時只需要應用程式本身的認証，直接使用 &lt;code>AppAssertionCredentials&lt;/code> 可以不需透過 &lt;code>Flow&lt;/code> 來建立 &lt;code>Credentials&lt;/code>物件&lt;/p></description></item></channel></rss>